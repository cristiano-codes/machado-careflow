// src/services/api.ts // Centraliza todas as chamadas HTTP do frontend (login, verify, users, settings, etc.)  /**  * Descobre o melhor BASE URL para a API.  * Preferência:  * 1) VITE_API_BASE_URL (ex.: "/api" com proxy do Vite, ou "http://localhost:3000/api")  * 2) Fallback automático baseado no hostname atual (http://<host>:3000/api)  */ function resolveApiBase(): string {   const envBase = import.meta.env?.VITE_API_BASE_URL as string | undefined;   if (envBase && envBase.trim().length > 0) {     return envBase; // ex.: "/api" (proxy) OU "http://localhost:3000/api"   }    const hostname = window.location.hostname;   const isIPv4 = /^\d{1,3}(\.\d{1,3}){3}$/.test(hostname);   const isLocal =     hostname === "localhost" ||     hostname === "127.0.0.1" ||     isIPv4 ||     hostname.startsWith("192.168.") ||     hostname.startsWith("10.") ||     /^172\.(1[6-9]|2[0-9]|3[0-1])\./.test(hostname);    // Fora de rede local, você pode ligar um demo-mode, se quiser   // Aqui mantemos apenas o fallback de base URL.   if (isLocal) {     return `http://${hostname}:3000/api`;   }    return "/api"; }  const API_BASE_URL = resolveApiBase();  export type LoginResponse = {   success: boolean;   message: string;   token?: string;   user?: {     id: string | number;     username: string;     email: string;     name: string;     role: string;     status?: string;     first_access?: boolean;     must_change_password?: boolean;     professional_id?: string | number | null;     can_view_all_professionals?: boolean;     allow_professional_view_others?: boolean;     permissions?: string[];     created_at?: string;     updated_at?: string;   }; };  export type User = {   id: string | number;   username: string;   email: string;   name: string;   role: string;   status?: string;   first_access?: boolean;   must_change_password?: boolean;   professional_id?: string | number | null;   professional_label?: string | null;   can_view_all_professionals?: boolean;   allow_professional_view_others?: boolean;   permissions?: string[];   created_at?: string;   updated_at?: string; };  export type ManagedUser = User & {   status: string;   created_at: string; };  export type LinkableProfessionalUser = {   id: string;   name: string;   email?: string | null;   username?: string | null;   status?: string | null;   professional_id?: string | null; };  export type RegistrationMode = "ADMIN_ONLY" | "PUBLIC_SIGNUP" | "INVITE_ONLY"; export type PublicSignupDefaultStatus = "pendente" | "ativo"; export type LinkPolicy =   | "MANUAL_LINK_ADMIN"   | "AUTO_LINK_BY_EMAIL"   | "SELF_CLAIM_WITH_APPROVAL";  export type SettingsPayload = {   instituicao_nome: string;   instituicao_email: string;   instituicao_telefone: string;   instituicao_endereco: string;   instituicao_logo_base64?: string | null;   email_notifications: boolean;   sms_notifications: boolean;   push_notifications: boolean;   weekly_reports: boolean;   two_factor_auth: boolean;   password_expiry_days: number;   max_login_attempts: number;   session_timeout: number;   backup_frequency: "daily" | "weekly" | "monthly" | string;   data_retention_days: number;   auto_updates: boolean;   debug_mode: boolean;   registration_mode: RegistrationMode;   public_signup_default_status: PublicSignupDefaultStatus;   link_policy: LinkPolicy;   allow_create_user_from_professional: boolean;   block_duplicate_email: boolean;   allow_public_registration: boolean;   allow_professional_view_others: boolean;   business_hours: BusinessHours;   professionals_config: ProfessionalsConfig; };  export type OperatingDays = {   seg: boolean;   ter: boolean;   qua: boolean;   qui: boolean;   sex: boolean;   sab: boolean;   dom: boolean; };  export type BusinessHours = {   opening_time: string;   closing_time: string;   lunch_break_minutes: number;   operating_days: OperatingDays; };  export type ProfessionalsConfig = {   allowed_contract_types: string[];   suggested_weekly_hours: number[]; };  export type WeekScale = {   seg: boolean;   ter: boolean;   qua: boolean;   qui: boolean;   sex: boolean; };  export type ProfessionalRole = {   id: number;   nome: string;   ativo: boolean;   created_at?: string;   updated_at?: string; };  export type ProfessionalPayload = {   name: string;   email: string;   username: string;   phone?: string;   role?: string;   crp?: string;   specialty?: string;   funcao?: string;   role_id?: number | null;   horas_semanais?: number | null;   data_nascimento?: string | null;   tipo_contrato: string;   escala_semanal?: WeekScale;   status?: "ATIVO" | "INATIVO"; };  type SettingsResponse = {   success: boolean;   settings?: SettingsPayload;   data?: SettingsPayload;   message?: string; };  export type ProfessionalSummary = {   id: string;   user_name?: string | null;   role_nome?: string | null;   funcao?: string | null;   status?: string; };  export type ProfessionalMeResponse = {   success: boolean;   professional_id: string | null;   can_view_all_professionals: boolean;   allow_professional_view_others: boolean;   professional: ProfessionalSummary | null;   message?: string; };  export type ProfessionalLinkRequestStatus = "pending" | "approved" | "rejected";  export type ProfessionalLinkRequest = {   id: string;   user_id: string;   professional_id: string;   status: ProfessionalLinkRequestStatus;   notes?: string | null;   created_at?: string;   updated_at?: string;   decided_at?: string | null;   decided_by_user_id?: string | null;   user_name?: string | null;   user_email?: string | null;   professional_name?: string | null;   professional_email?: string | null;   decided_by_name?: string | null; };  type PublicSettingsResponse = {   success: boolean;   registration_mode?: RegistrationMode;   allow_public_registration: boolean;   instituicao_nome?: string | null;   instituicao_logo_url?: string | null;   instituicao_logo_base64?: string | null;   message?: string; };  class ApiService {   private getAuthHeaders() {     const token = localStorage.getItem("token");     return {       "Content-Type": "application/json",       ...(token ? { Authorization: `Bearer ${token}` } : {}),     };   }    // ---------- AUTH ----------   async login(username: string, password: string): Promise<LoginResponse> {     const response = await fetch(`${API_BASE_URL}/auth/login`, {       method: "POST",       headers: { "Content-Type": "application/json" },       body: JSON.stringify({ username, password }),     });      const data = (await response.json()) as LoginResponse;      if (data?.success && data?.token) {       localStorage.setItem("token", data.token);       if (data.user) localStorage.setItem("user", JSON.stringify(data.user));     }      return data;   }    async verifyToken(): Promise<{ valid: boolean; user?: User }> {     const token = localStorage.getItem("token");     if (!token) return { valid: false };      const response = await fetch(`${API_BASE_URL}/auth/verify`, {       headers: this.getAuthHeaders(),     });      const data = await response.json();      if (data?.success) {       return { valid: true, user: data.user as User };     } else {       localStorage.removeItem("token");       localStorage.removeItem("user");       return { valid: false };     }   }    logout() {     localStorage.removeItem("token");     localStorage.removeItem("user");   }    async checkFirstAccess(): Promise<{ firstAccess: boolean }> {     const resp = await fetch(`${API_BASE_URL}/auth/first-access`, {       headers: this.getAuthHeaders(),     });     return resp.json();   }    async changePassword(     currentPassword: string,     newPassword: string   ): Promise<{ success: boolean; message: string }> {     const resp = await fetch(`${API_BASE_URL}/auth/change-password`, {       method: "PUT",       headers: this.getAuthHeaders(),       body: JSON.stringify({ currentPassword, newPassword }),     });     return resp.json();   }    // ---------- USERS ----------   async getUsers(): Promise<{ users: ManagedUser[]; message?: string }> {     const response = await fetch(`${API_BASE_URL}/users`, {       headers: this.getAuthHeaders(),     });     const data = await response.json();     if (Array.isArray(data)) {       return { users: data as ManagedUser[] };     }     return {       users: Array.isArray(data?.users) ? (data.users as ManagedUser[]) : [],       message: data?.message,     };   }    async deleteUser(id: string | number): Promise<{ message: string }> {     const response = await fetch(`${API_BASE_URL}/users/${id}`, {       method: "DELETE",       headers: this.getAuthHeaders(),     });     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(data?.message || "Falha ao excluir usuario");     }     return { message: data?.message || "Usuario excluido com sucesso" };   }    async forcePasswordChange(id: string | number): Promise<{ message: string }> {     const response = await fetch(`${API_BASE_URL}/users/${id}/force-password-change`, {       method: "PATCH",       headers: this.getAuthHeaders(),     });     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(data?.message || "Falha ao forcar redefinicao de senha");     }     return {       message: data?.message || "Usuario devera redefinir a senha no proximo login",     };   }    async linkUserToProfessional(     userId: string | number,     professionalId: string   ): Promise<{ message: string }> {     const response = await fetch(`${API_BASE_URL}/users/${userId}/link-professional`, {       method: "POST",       headers: this.getAuthHeaders(),       body: JSON.stringify({ professional_id: professionalId }),     });     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(data?.message || "Falha ao vincular usuario ao profissional");     }     return { message: data?.message || "Vinculo atualizado com sucesso" };   }    async unlinkUserFromProfessional(     userId: string | number,     professionalId?: string   ): Promise<{ message: string }> {     const response = await fetch(`${API_BASE_URL}/users/${userId}/unlink-professional`, {       method: "POST",       headers: this.getAuthHeaders(),       body: JSON.stringify(         professionalId ? { professional_id: professionalId } : {}       ),     });     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(data?.message || "Falha ao desvincular usuario do profissional");     }     return { message: data?.message || "Vinculo removido com sucesso" };   }    async getLinkableProfessionalUsers(     professionalId?: string   ): Promise<LinkableProfessionalUser[]> {     const query = professionalId       ? `?professional_id=${encodeURIComponent(professionalId)}`       : "";     const response = await fetch(       `${API_BASE_URL}/profissionais/linkable-users${query}`,       {         headers: this.getAuthHeaders(),       }     );     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(         data?.message || "Falha ao carregar usuarios elegiveis para vinculo"       );     }     const users = Array.isArray(data?.users) ? data.users : [];     return users.map((item: any) => ({       id: String(item?.id ?? ""),       name: (item?.name || "").toString(),       email: item?.email ?? null,       username: item?.username ?? null,       status: item?.status ?? null,       professional_id:         item?.professional_id === null || item?.professional_id === undefined           ? null           : String(item.professional_id),     }));   }    async linkProfessionalUser(     professionalId: string,     userId: string | number   ): Promise<{ message: string }> {     const response = await fetch(       `${API_BASE_URL}/profissionais/${professionalId}/link-user`,       {         method: "PATCH",         headers: this.getAuthHeaders(),         body: JSON.stringify({ userId }),       }     );     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(data?.message || "Falha ao vincular usuario ao profissional");     }     return { message: data?.message || "Vinculo atualizado com sucesso" };   }    async unlinkProfessionalUser(     professionalId: string   ): Promise<{ message: string }> {     const response = await fetch(       `${API_BASE_URL}/profissionais/${professionalId}/unlink-user`,       {         method: "PATCH",         headers: this.getAuthHeaders(),       }     );     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(data?.message || "Falha ao desvincular usuario do profissional");     }     return { message: data?.message || "Vinculo removido com sucesso" };   }    async createProfessionalLinkRequest(     professionalId: string,     notes?: string   ): Promise<{ message: string; request?: ProfessionalLinkRequest }> {     const response = await fetch(       `${API_BASE_URL}/profissionais/${professionalId}/link-requests`,       {         method: "POST",         headers: this.getAuthHeaders(),         body: JSON.stringify(notes ? { notes } : {}),       }     );     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(data?.message || "Falha ao solicitar vinculo");     }     return {       message: data?.message || "Solicitacao de vinculo enviada com sucesso",       request: data?.request,     };   }    async getProfessionalLinkRequests(     status?: ProfessionalLinkRequestStatus   ): Promise<ProfessionalLinkRequest[]> {     const query = status ? `?status=${encodeURIComponent(status)}` : "";     const response = await fetch(`${API_BASE_URL}/profissionais/link-requests${query}`, {       headers: this.getAuthHeaders(),     });     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(data?.message || "Falha ao carregar solicitacoes de vinculo");     }     return Array.isArray(data?.requests) ? data.requests : [];   }    async approveProfessionalLinkRequest(     requestId: string,     notes?: string   ): Promise<{ message: string; request?: ProfessionalLinkRequest }> {     const response = await fetch(       `${API_BASE_URL}/profissionais/link-requests/${requestId}/approve`,       {         method: "PATCH",         headers: this.getAuthHeaders(),         body: JSON.stringify(notes ? { notes } : {}),       }     );     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(data?.message || "Falha ao aprovar solicitacao de vinculo");     }     return {       message: data?.message || "Solicitacao aprovada com sucesso",       request: data?.request,     };   }    async rejectProfessionalLinkRequest(     requestId: string,     notes?: string   ): Promise<{ message: string; request?: ProfessionalLinkRequest }> {     const response = await fetch(       `${API_BASE_URL}/profissionais/link-requests/${requestId}/reject`,       {         method: "PATCH",         headers: this.getAuthHeaders(),         body: JSON.stringify(notes ? { notes } : {}),       }     );     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(data?.message || "Falha ao rejeitar solicitacao de vinculo");     }     return {       message: data?.message || "Solicitacao rejeitada com sucesso",       request: data?.request,     };   }    // ---------- SETTINGS ----------   /**    * Busca as configurações atuais    */   async getSettings(): Promise<SettingsResponse> {     const r = await fetch(`${API_BASE_URL}/settings`, {       headers: this.getAuthHeaders(),     });     if (!r.ok) {       throw new Error("Falha ao carregar configurações");     }     return r.json();   }    /**    * Salva as configurações no backend (usa exatamente as chaves snake_case    * que o backend espera no body).    */   async saveSettings(payload: SettingsPayload): Promise<SettingsResponse> {     const r = await fetch(`${API_BASE_URL}/settings`, {       method: "PUT",       headers: this.getAuthHeaders(),       body: JSON.stringify(payload),     });     if (!r.ok) {       const txt = await r.text();       let message = `Falha ao salvar configurações (HTTP ${r.status})`;       try {         const parsed = JSON.parse(txt);         if (parsed && typeof parsed.message === "string" && parsed.message.trim()) {           message = parsed.message;         }       } catch {         if (txt.trim()) {           message = `${message}: ${txt}`;         }       }       throw new Error(message);     }     return r.json();   }    async getPublicSettings(): Promise<PublicSettingsResponse> {     const response = await fetch(`${API_BASE_URL}/settings/public`, {       headers: { "Content-Type": "application/json" },     });     let raw: unknown = {};      try {       raw = await response.json();     } catch {       raw = {};     }      const parsed = (raw && typeof raw === "object" ? raw : {}) as Record<string, unknown>;     const fromSettings =       parsed.settings && typeof parsed.settings === "object"         ? (parsed.settings as Record<string, unknown>)         : null;     const fromData =       parsed.data && typeof parsed.data === "object"         ? (parsed.data as Record<string, unknown>)         : null;      function pick(field: string): unknown {       if (Object.prototype.hasOwnProperty.call(parsed, field)) return parsed[field];       if (fromSettings && Object.prototype.hasOwnProperty.call(fromSettings, field)) {         return fromSettings[field];       }       if (fromData && Object.prototype.hasOwnProperty.call(fromData, field)) {         return fromData[field];       }       return undefined;     }      function parseOptionalString(       value: unknown     ): string | null | undefined {       if (value === undefined) return undefined;       if (value === null) return null;       if (typeof value !== "string") return undefined;       const trimmed = value.trim();       return trimmed.length > 0 ? trimmed : null;     }      const allowRaw = pick("allow_public_registration");     const allow = typeof allowRaw === "boolean" ? allowRaw : false;     const registrationModeRaw = pick("registration_mode");     const registrationMode =       registrationModeRaw === "ADMIN_ONLY" ||       registrationModeRaw === "PUBLIC_SIGNUP" ||       registrationModeRaw === "INVITE_ONLY"         ? registrationModeRaw         : undefined;     const instituicaoNome = parseOptionalString(pick("instituicao_nome"));     const instituicaoLogoUrl = parseOptionalString(pick("instituicao_logo_url"));     const instituicaoLogoBase64 = parseOptionalString(pick("instituicao_logo_base64"));      const message = typeof parsed.message === "string" ? parsed.message : undefined;      return {       success: response.ok && parsed.success !== false,       registration_mode: registrationMode,       allow_public_registration: allow,       instituicao_nome: instituicaoNome,       instituicao_logo_url: instituicaoLogoUrl,       instituicao_logo_base64: instituicaoLogoBase64,       message,     };   }    // ---------- SETTINGS: PROFESSIONAL ROLES ----------   async getProfessionalRoles(includeInactive = false): Promise<{     success: boolean;     roles: ProfessionalRole[];     message?: string;   }> {     const suffix = includeInactive ? "?all=1" : "";     const response = await fetch(`${API_BASE_URL}/settings/professional-roles${suffix}`, {       headers: this.getAuthHeaders(),     });     const data = await response.json();     if (!response.ok) {       throw new Error(data?.message || "Falha ao carregar funcoes profissionais");     }     return {       success: Boolean(data?.success),       roles: Array.isArray(data?.roles) ? data.roles : [],       message: data?.message,     };   }    async createProfessionalRole(nome: string): Promise<{     success: boolean;     role?: ProfessionalRole;     message?: string;   }> {     const response = await fetch(`${API_BASE_URL}/settings/professional-roles`, {       method: "POST",       headers: this.getAuthHeaders(),       body: JSON.stringify({ nome }),     });     const data = await response.json();     if (!response.ok) {       throw new Error(data?.message || "Falha ao criar funcao profissional");     }     return data;   }    async updateProfessionalRole(id: number, nome: string): Promise<{     success: boolean;     role?: ProfessionalRole;     message?: string;   }> {     const response = await fetch(`${API_BASE_URL}/settings/professional-roles/${id}`, {       method: "PUT",       headers: this.getAuthHeaders(),       body: JSON.stringify({ nome }),     });     const data = await response.json();     if (!response.ok) {       throw new Error(data?.message || "Falha ao editar funcao profissional");     }     return data;   }    async setProfessionalRoleActive(id: number, ativo: boolean): Promise<{     success: boolean;     role?: ProfessionalRole;     message?: string;   }> {     const response = await fetch(`${API_BASE_URL}/settings/professional-roles/${id}/ativo`, {       method: "PATCH",       headers: this.getAuthHeaders(),       body: JSON.stringify({ ativo }),     });     const data = await response.json();     if (!response.ok) {       throw new Error(data?.message || "Falha ao atualizar status da funcao profissional");     }     return data;   }    // ---------- PROFISSIONAIS ----------   async getProfessionals(options?: string | { date?: string; forAgenda?: boolean }) {     const date = typeof options === "string" ? options : options?.date;     const forAgenda =       typeof options === "object" && options !== null ? options.forAgenda === true : false;     const params = new URLSearchParams();     if (date) params.set("date", date);     if (forAgenda) params.set("for_agenda", "1");     const query = params.toString().length > 0 ? `?${params.toString()}` : "";     const response = await fetch(`${API_BASE_URL}/profissionais${query}`, {       headers: this.getAuthHeaders(),     });     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(data?.message || "Falha ao carregar profissionais");     }     return data;   }    async createProfessional(payload: ProfessionalPayload) {     const response = await fetch(`${API_BASE_URL}/profissionais`, {       method: "POST",       headers: this.getAuthHeaders(),       body: JSON.stringify(payload),     });     return response.json();   }    async updateProfessional(id: string, payload: Partial<ProfessionalPayload>) {     const response = await fetch(`${API_BASE_URL}/profissionais/${id}`, {       method: "PUT",       headers: this.getAuthHeaders(),       body: JSON.stringify(payload),     });     return response.json();   }    async updateProfessionalStatus(id: string, status: "ATIVO" | "INATIVO") {     const response = await fetch(`${API_BASE_URL}/profissionais/${id}/status`, {       method: "PATCH",       headers: this.getAuthHeaders(),       body: JSON.stringify({ status }),     });     return response.json();   }    async deleteProfessional(id: string) {     const response = await fetch(`${API_BASE_URL}/profissionais/${id}`, {       method: "DELETE",       headers: this.getAuthHeaders(),     });     return response.json();   }    async getProfessionalAgenda(id: string, date?: string) {     const query = date ? `?date=${encodeURIComponent(date)}` : "";     const response = await fetch(`${API_BASE_URL}/profissionais/${id}/agenda${query}`, {       headers: this.getAuthHeaders(),     });     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(data?.message || "Falha ao carregar agenda do profissional");     }     return data;   }    async getProfessionalMe(): Promise<ProfessionalMeResponse> {     const response = await fetch(`${API_BASE_URL}/profissionais/me`, {       headers: this.getAuthHeaders(),     });     const data = await response.json().catch(() => ({}));     if (!response.ok) {       throw new Error(data?.message || "Falha ao carregar contexto profissional");     }     return {       success: data?.success === true,       professional_id:         data?.professional_id === null || data?.professional_id === undefined           ? null           : String(data.professional_id),       can_view_all_professionals: data?.can_view_all_professionals === true,       allow_professional_view_others: data?.allow_professional_view_others === true,       professional: data?.professional || null,       message: data?.message,     };   }    async getProfessionalsStats(date?: string) {     const query = date ? `?date=${encodeURIComponent(date)}` : "";     const response = await fetch(`${API_BASE_URL}/profissionais/stats/resumo${query}`, {       headers: this.getAuthHeaders(),     });     return response.json();   }    // ---------- PACIENTES ----------   async getPatients() {     const response = await fetch(`${API_BASE_URL}/pacientes`, {       headers: this.getAuthHeaders(),     });     const data = await response.json();     if (Array.isArray(data)) return data;     if (Array.isArray(data?.pacientes)) return data.pacientes;     return [];   }    // ---------- ENTREVISTAS SOCIAIS ----------   async getSocialInterviews(patientId?: string) {     const query = patientId ? `?patient_id=${encodeURIComponent(patientId)}` : "";     const response = await fetch(`${API_BASE_URL}/social-interviews${query}`, {       headers: this.getAuthHeaders(),     });     if (!response.ok) {       throw new Error("Falha ao carregar entrevistas sociais");     }     return response.json();   }    async createSocialInterview(payload: Record<string, unknown>) {     const response = await fetch(`${API_BASE_URL}/social-interviews`, {       method: "POST",       headers: this.getAuthHeaders(),       body: JSON.stringify(payload),     });     if (!response.ok) {       const text = await response.text();       throw new Error(`Erro ao criar entrevista social: ${text}`);     }     return response.json();   }    async updateSocialInterview(id: string, payload: Record<string, unknown>) {     const response = await fetch(`${API_BASE_URL}/social-interviews/${id}`, {       method: "PUT",       headers: this.getAuthHeaders(),       body: JSON.stringify(payload),     });     if (!response.ok) {       const text = await response.text();       throw new Error(`Erro ao atualizar entrevista social: ${text}`);     }     return response.json();   } }  export const apiService = new ApiService(); export { API_BASE_URL };